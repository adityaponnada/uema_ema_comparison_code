---
title: "exploration_and_data_cleaning"
author: "Aditya Ponnada"
date: "7/3/2021"
output: html_document
---

## Import libraries
```{r}

library(psych)
library(reshape2)
library(ggplot2)
library(plyr)
library(dplyr)
library(plotly)
options(digits = 4)
options(digits.secs = 3)
library(corrplot)
library(lme4)

```

## Read and combine the report files
Read all the report files and combine them into one data frame for analysis
```{r}

# report_file_loc = "D:/TIME_CLUSTER_PREPROCESSED_20210702/daily_report/"
# 
# file_pattern <- paste0(report_file_loc, '*@timestudy_com.csv')
# 
# file_matches <- Sys.glob(file_pattern)
# 
# daily_report_df <- do.call(rbind, lapply(file_matches, read.csv))

# daily_report_df <- read.csv("E:/SHARED_GLOBUS_DATA/Combined_daily_report/combined_report_1634336199.8833838.csv")
daily_report_df <- read.csv("E:/SHARED_GLOBUS_DATA/Combined_daily_report/combined_report_v1_1637614608.3273082.csv")

```


## Stitch changed ids together
For some participants the ID was changed. So we merge those rows together
```{r}
daily_report_df$participant_ID[daily_report_df$participant_ID == "upliftedsulfatedreamboat@timestudy_com"] <- "startlingrevengevillage@timestudy_com"

daily_report_df <- subset(daily_report_df, daily_report_df$participant_ID != "stephen4_internal@timestudy_com")
daily_report_df <- subset(daily_report_df, daily_report_df$participant_ID != "stephen6_internal@timestudy_com")
```

## Read the watch assignment file
This file is needed to:
1. Filter time dates with uEMA that occurred before the official watch training
2. also filter out the participants that have been unenrolled in the first two bursts before the watch was even assigned

Note: In this file, participant status codes mean:

1=first burst
2=active
3= staff unenrolled
4=participant withdrew
5=competed

```{r}

participant_status_df <- read.csv(file = "D:/TIME_CLUSTER_PREPROCESSED_20210702/TIMEMAIN-WatchTrainingDate_DATA_LABELS_2021-11-23_0937.csv", sep = ",", header = TRUE)

# names(participant_status_df) <- c("record_id", "participant_id", "participant_status", "watch_assign_date", "device_tracking")
names(participant_status_df) <- c("record_id", "participant_id", "watch_assign_date")

participant_status_df$participant_id <- paste0(participant_status_df$participant_id, "@timestudy_com")

```

Remove participants who were never assigned a single watch
```{r}

no_watch_assigned_df <- subset(participant_status_df, participant_status_df$watch_assign_date == "")

no_watch_users = unique(no_watch_assigned_df$participant_id)

```

Keep a dataframe of watch assigned participants
```{r}

watch_users_df <- subset(participant_status_df, participant_status_df$watch_assign_date != "")

```


Convert the watch assignment date into date time stamp or object for future filtering
```{r}

watch_users_df$watch_training_day <- as.POSIXct(watch_users_df$watch_assign_date, format = "%Y-%m-%d")


```


## Filter no watch users
Filter out users who have never been assigned a watch
```{r}

`%!in%` <- Negate(`%in%`)

daily_report_subset <- subset(daily_report_df, daily_report_df$participant_ID %!in% no_watch_users)

```

## Create a function to filter out user names with less than six months of data in total
We are only looking at the users who have completed at least six months in the study. Thus, we will discard any user who has not completed six months yet
```{r}

keep_six_months_completed <- function(df, num_months){
  num_days = num_months * 30
  # count each 'name', assign result to an object 'tt'
  tt <- table(df$participant_ID)
  # subset data frame by a logical vector
  # 'TRUE' rows are kept, 'FALSE' rows are removed.
  # assign the result to a data frame with a new name
  df2 <- subset(df, df$participant_ID %in% names(tt[tt >= num_days]))
  
  return(df2)
}


```



Use the function to keep users with at least 6 months of data
```{r}

daily_report_6m_df <- keep_six_months_completed(daily_report_df, 12)

```


Add a dummy df for only those with 12 months completed - uncomment when only want to run on 12 month users
```{r}
# test_df <- keep_six_months_completed(daily_report_df, 12)
# 
# daily_report_6m_df <- test_df

```



## Convert sleep wake times to date time objects
```{r}

daily_report_6m_df$current_wake_timestamp <- as.POSIXct(daily_report_6m_df$current_wake_time, format = "%Y-%m-%d %H:%M:%OS")
daily_report_6m_df$current_sleep_timestamp <- as.POSIXct(daily_report_6m_df$current_sleep_time, format = "%Y-%m-%d %H:%M:%OS")

```

## Remove days with awkward sleep duration due to error
Check summary first
```{r}

daily_report_6m_df$sleep_time_reported_hr <- as.numeric(daily_report_6m_df$sleep_time_reported_hr)

describe(daily_report_6m_df$sleep_time_reported_hr)

```

Remove awkward sleep times above 24 hours
```{r}

daily_report_6m_df <- subset(daily_report_6m_df, daily_report_6m_df$sleep_time_reported_hr <= 24.0)

```


## Split the dataframe into uEMA and EMA data frames
use TIME and BURST days study mode for separation
```{r}

time_df <- subset(daily_report_6m_df, daily_report_6m_df$study_mode == "TIME")
burst_df <- subset(daily_report_6m_df, daily_report_6m_df$study_mode == "BURST")

```

keep only watch assigned days and only days after the watch assignment took place
```{r}
time_df <- subset(time_df, time_df$watch_assigned == "True")
```

Now only keep the dates a day after the watch training date
```{r}

time_df$date_stamp <- as.POSIXct(time_df$date, format = "%Y-%m-%d")

p_ids <- unique(time_df$participant_ID)


for (p_id in p_ids){
  # print(p_id)
  start_date <- watch_users_df$watch_training_day[watch_users_df$participant_id == p_id]
  # print(start_date)
  time_df <- time_df[!(time_df$participant_ID == p_id & time_df$date_stamp <= start_date), ]
  # print(nrow(time_df))
}

```

## Convert prompt counts to numeric
```{r}

time_df$uema_prompted_num <- as.numeric(time_df$uema_prompted_num)
time_df$uema_completed_num <- as.numeric(time_df$uema_completed_num)


```


## Use sleep time reported to get the expected number of uEMA and burst EMA prompts

Rubric to be used:
uEMA num prompts = (24.0 - sleep_time - 0.50)*4.0 --> convert to integer
burst EMA num prompts = (24.0 - sleep_time - 1.0)*1 --> convert to integet

Define the constants
```{r}

uEMA_PER_HOUR = 4.0
EMA_PER_HOUR = 1.0
uEMA_BUFFER_HOUR = 0.5
EMA_BUFFER_HOUR = 1.0

DAY_HOUR = 24.0

```

Compute expected prompts for burst EMA
```{r}


burst_df$burst_ema_expected_num <- as.integer((DAY_HOUR - burst_df$sleep_time_reported_hr - EMA_BUFFER_HOUR)*EMA_PER_HOUR)

```

Compute expected promtps for uEMA
```{r}

time_df$uema_expected_num <- as.integer((DAY_HOUR - time_df$sleep_time_reported_hr - uEMA_BUFFER_HOUR)*uEMA_PER_HOUR)

```

## Convert response rate columns to numeric
```{r}
burst_df$burst_ema_completion_rate <- as.numeric(burst_df$burst_ema_completion_rate)
burst_df$burst_ema_compliance_rate <- as.numeric(burst_df$burst_ema_compliance_rate)

time_df$uema_completion_rate <- as.numeric(time_df$uema_completion_rate)
time_df$uema_compliance_rate <- as.numeric(time_df$uema_compliance_rate)


time_df$uema_validation_perc <- as.numeric(time_df$uema_validation_perc)

time_df$uema_undo_num <- as.numeric(time_df$uema_undo_num)

time_df$uema_resp_time_mean <- as.numeric(time_df$uema_resp_time_mean)

burst_df$date_object <- as.POSIXct(burst_df$date, format = "%Y-%m-%d")
time_df$date_object <- as.POSIXct(time_df$date, format = "%Y-%m-%d")

```

Convert count columns to numeric:
```{r}

burst_df$burst_ema_expected_num <- as.numeric(burst_df$burst_ema_expected_num)
burst_df$burst_ema_original_prompted_num <- as.numeric(burst_df$burst_ema_original_prompted_num)
burst_df$burst_ema_completed_num <- as.numeric(burst_df$burst_ema_completed_num)

time_df$uema_expected_num <- as.numeric(time_df$uema_expected_num)
time_df$uema_prompted_num <- as.numeric(time_df$uema_prompted_num)
time_df$uema_completed_num <- as.numeric(time_df$uema_completed_num)

```


if there are dates to be filtered because of technical malfunction, include that code here
```{r}
## Read the missing data file here
missing_notes_file <- read.csv("D:/uema_ema_comparison_CHI/missing_notes_files.csv", sep = ",", header = TRUE)

missing_notes_file <- subset(missing_notes_file, missing_notes_file$ACTION == "EXCLUDE")


# replace empty columns with the same date as the other column

missing_notes_file$START_DATE <- ifelse(missing_notes_file$START_DATE == "", missing_notes_file$END_DATE, missing_notes_file$START_DATE)
missing_notes_file$END_DATE <- ifelse(missing_notes_file$END_DATE == "", missing_notes_file$START_DATE, missing_notes_file$END_DATE)

# Convert to date time objects
missing_notes_file$START_DATE <- as.POSIXct(missing_notes_file$START_DATE, format = "%Y-%m-%d")
missing_notes_file$END_DATE <- as.POSIXct(missing_notes_file$END_DATE, format = "%Y-%m-%d")

missing_notes_file$P_ID <- paste0(missing_notes_file$P_ID, "@timestudy_com")


```

Filter out these dates from the combined daily report file - first the common dates
```{r}

all_pid_row <- subset(missing_notes_file, missing_notes_file$P_ID == "ALL_PARTICIPANTS@timestudy_com")

global_start_date <- all_pid_row$START_DATE
global_end_date <- all_pid_row$END_DATE

burst_df <- burst_df[(burst_df$date_object <= global_start_date | burst_df$date_object >= global_end_date), ]


```

Filter out other phone exclusion dates for the burst_df
```{r}



filter_exclusion_dates <- function(report_df, missing_df, device){
  missing_df <- subset(missing_df, missing_df$DEVICE == device | missing_df$DEVICE == "BOTH")
  missing_df <- subset(missing_df, missing_df$P_ID != "ALL_PARTICIPANTS@timestudy_com")
  pid_list <- unique(missing_df$P_ID)
  for (pid in pid_list){
    # print(paste0("participant: ", pid))
    missing_pid_subset <- subset(missing_df, missing_df$P_ID == pid)
    # print(nrow(missing_pid_subset))
    for (i in 1:nrow(missing_pid_subset)){
      # print(paste0("i: ", i))
      start_date <- missing_pid_subset$START_DATE[i]
      end_date <- missing_pid_subset$END_DATE[i]
      # print(start_date)
      # print(end_date)
      # print(paste0("nrow before: ", nrow(report_df)))
      test_subset <- subset(report_df, report_df$participant_ID == pid)
      test_subset <- test_subset[(test_subset$date_object >= start_date & test_subset$date_object <= end_date), ]
      # print(paste0("test_df nrow: ", nrow(test_subset)))
      # print(paste0("row: ", test_subset$date_object))
      report_df <- dplyr::setdiff(report_df, test_subset)
      # report_df <- subset(report_df, !(report_df$participant_ID == pid & report_df$date_object >= start_date) | (report_df$participant_ID == pid & report_df$date_object <= end_date))
      # print(paste0("nrow after: ", nrow(report_df)))
    }
  }
  
  return(report_df)
}


```

Get burst and time df updated
```{r}
# original number of rows 6168

burst_df <- filter_exclusion_dates(burst_df, missing_notes_file, "PHONE")

# original number of rows 13415
time_df <- filter_exclusion_dates(time_df, missing_notes_file, "WATCH")
```

Also check by removing outliers
```{r}

remove_outliers_from_df <- function(df){
  outliers <- c("uniformlyharmfulbush@timestudy_com", "penpalsandbanklifting@timstudy_com")
  df <- subset(df, df$participant_ID %!in% outliers)
  return(df)
}

```

Get non-outlier dfs
```{r}
time_df <- remove_outliers_from_df(time_df)
burst_df <- remove_outliers_from_df(burst_df)


```


## Create a comprehensive completion rate for uEMA
```{r}

time_df$uema_prompted_num <- as.numeric(time_df$uema_prompted_num)
time_df$uema_completed_num <- as.numeric(time_df$uema_completed_num)
time_df$uema_cs_completed <- as.numeric(time_df$uema_cs_completed)
time_df$uema_partial_completed_num <- as.numeric(time_df$uema_partial_completed_num)
time_df$uema_trivia_completed <- as.numeric(time_df$uema_trivia_completed)

time_df$uema_all_completion_rate <- (time_df$uema_completed_num + time_df$uema_cs_completed + time_df$uema_trivia_completed)/time_df$uema_prompted_num

```


## Add value caps for response rates
```{r}

burst_df$burst_ema_completion_rate[burst_df$burst_ema_completion_rate >= 1.0] <- 1.0
burst_df$burst_ema_compliance_rate[burst_df$burst_ema_compliance_rate >= 1.0] <- 1.0
time_df$uema_completion_rate[time_df$uema_completion_rate >= 1.0] <- 1.0
time_df$uema_compliance_rate[time_df$uema_compliance_rate >= 1.0] <- 1.0


```





## Plot day level completion and compliance rate for EMA (with mean median highlighted)

Burst EMA completion rate

```{r}

describe(burst_df$burst_ema_completion_rate)

mean_val = mean(burst_df$burst_ema_completion_rate)
median_val = median(burst_df$burst_ema_completion_rate)

burst_completion_plot <- ggplot(burst_df, aes(x=burst_ema_completion_rate)) + 
  geom_histogram(binwidth = 0.10) +
  geom_vline(aes(xintercept = mean(burst_ema_completion_rate)), data=burst_df, linetype=5, color = "red") +
  geom_vline(aes(xintercept = median(burst_ema_completion_rate)), data=burst_df, linetype=5, color = "green") +
  geom_text(aes(x=mean_val, label=paste0("\nmean = ", format(round(mean_val, 2), nsmall = 2)), y=2000), colour="black", angle=90, text=element_text(size=10)) +
  geom_text(aes(x=median_val, label=paste0("\nmed = ", format(round(median_val, 2), nsmall = 2)), y=2000), colour="black", angle=90, text=element_text(size=10)) +
  ylim(0, 3000) +
  ggtitle("Burst EMA Completion Rate per BURST day")

```

Burst EMA compliance rate
```{r}

describe(burst_df$burst_ema_compliance_rate)

mean_val = mean(burst_df$burst_ema_compliance_rate, na.rm = TRUE)
median_val = median(burst_df$burst_ema_compliance_rate, na.rm = TRUE)

burst_compliance_plot <- ggplot(burst_df, aes(x=burst_ema_compliance_rate)) + 
  geom_histogram(binwidth = 0.10) +
  geom_vline(aes(xintercept = mean(burst_ema_compliance_rate, na.rm = TRUE)), data=burst_df, linetype=5, color = "red") +
  geom_vline(aes(xintercept = median(burst_ema_compliance_rate, na.rm = TRUE)), data=burst_df, linetype=5, color = "green") +
  geom_text(aes(x=mean_val, label=paste0("\nmean = ", format(round(mean_val, 2), nsmall = 2)), y=2000), colour="black", angle=90, text=element_text(size=10)) +
  geom_text(aes(x=median_val, label=paste0("\nmed = ", format(round(median_val, 2), nsmall = 2)), y=2000), colour="black", angle=90, text=element_text(size=10)) +
  ylim(0, 3000) +
  ggtitle("Burst EMA Compliance Rate per BURST day")


```

uEMA completion rate
```{r}

describe(time_df$uema_completion_rate)

mean_val = mean(time_df$uema_completion_rate)
median_val = median(time_df$uema_completion_rate)

uema_completion_plot <- ggplot(time_df, aes(x=uema_completion_rate)) + 
  geom_histogram(binwidth = 0.05) +
  geom_vline(aes(xintercept = mean(uema_completion_rate)), data=time_df, linetype=5, color = "red") +
  geom_vline(aes(xintercept = median(uema_completion_rate)), data=time_df, linetype=5, color = "green") +
  geom_text(aes(x=mean_val, label=paste0("\nmean = ", format(round(mean_val, 2), nsmall = 2)), y=2000), colour="black", angle=90, text=element_text(size=10)) +
  geom_text(aes(x=median_val, label=paste0("\nmed = ", format(round(median_val, 2), nsmall = 2)), y=2000), colour="black", angle=90, text=element_text(size=10)) +
  ylim(0, 3000) +
  ggtitle("uEMA Completion Rate per TIME day")

```

uEMA compliance rate
```{r}
describe(time_df$uema_compliance_rate)

mean_val = mean(time_df$uema_compliance_rate, na.rm = TRUE)
median_val = median(time_df$uema_compliance_rate, na.rm = TRUE)

uema_compliance_plot <- ggplot(time_df, aes(x=uema_compliance_rate)) + 
  geom_histogram(binwidth = 0.05) +
  geom_vline(aes(xintercept = mean(uema_compliance_rate, na.rm = TRUE)), data=time_df, linetype=5, color = "red") +
  geom_vline(aes(xintercept = median(uema_compliance_rate, na.rm = TRUE)), data=time_df, linetype=5, color = "green") +
  geom_text(aes(x=mean_val, label=paste0("\nmean = ", format(round(mean_val, 2), nsmall = 2)), y=2000), colour="black", angle=90, text=element_text(size=10)) +
  geom_text(aes(x=median_val, label=paste0("\nmed = ", format(round(median_val, 2), nsmall = 2)), y=2000), colour="black", angle=90, text=element_text(size=10)) +
  ylim(0, 3000) +
  ggtitle("uEMA Compliance Rate per TIME day")


```

## Get validation score and distribution
Compute the validation score distribution for the uEMA days

```{r}

time_df$uema_validation_perc <- as.numeric(time_df$uema_validation_perc)

describe(time_df$uema_validation_perc)

mean_val = mean(time_df$uema_validation_perc, na.rm = TRUE)
median_val = median(time_df$uema_validation_perc, na.rm = TRUE)

uema_validation_plot <- ggplot(time_df, aes(x=uema_validation_perc)) + 
  geom_histogram(binwidth = 0.05) +
  geom_vline(aes(xintercept = mean(uema_validation_perc, na.rm = TRUE)), data=time_df, linetype=5, color = "red") +
  geom_vline(aes(xintercept = median(uema_validation_perc, na.rm = TRUE)), data=time_df, linetype=5, color = "green") +
  geom_text(aes(x=mean_val, label=paste0("\nmean = ", format(round(mean_val, 2), nsmall = 2)), y=700), colour="black", angle=90, text=element_text(size=10)) +
  geom_text(aes(x=median_val, label=paste0("\nmed = ", format(round(median_val, 2), nsmall = 2)), y=700), colour="black", angle=90, text=element_text(size=10)) +
  ggtitle("uEMA Validation Rate per TIME day")



```


## Outlier vs non-outlier comparison
Remove outlier and compare the percentages with and without the outlier
```{r}

time_sans_outlier_df <- subset(time_df, time_df$participant_ID != "uniformlyharmfulbush@timestudy_com")


```


## Create participant level data frames
This data frame is to get a wide form for each participant

First, we start with the time_df for uema

```{r}

time_keep_cols <- c("participant_ID", "uema_completed_num", "uema_prompted_num", "uema_expected_num", "uema_validation_perc")

selected_TIME_df <- time_df[, time_keep_cols]

```

Now create a function to return the completely aggregated df
```{r}

aggregate_time_df <- function(df){
  
  df1 <- df[, c("participant_ID", "uema_completed_num", "uema_prompted_num", "uema_expected_num")]
  num_time_days_df <- df %>% count(participant_ID)
  df2 <- aggregate(.~participant_ID, df1, sum)
  df3 <- aggregate(uema_validation_perc~participant_ID, df, mean, na.rm=TRUE, na.action=na.pass)
  df2$num_time_days <- num_time_days_df$n
  df2 <- join(df2, df3)
  return(df2)
  
}

```

Use the function to get the aggregate df

```{r}

time_pid_df <- aggregate_time_df(selected_TIME_df)

```

Add compliance and completion rate columns

```{r}

time_pid_df$uema_completion_rate <- time_pid_df$uema_completed_num/time_pid_df$uema_prompted_num
time_pid_df$uema_compliance_rate <- time_pid_df$uema_completed_num/time_pid_df$uema_expected_num

```


Second, we do the same with burst EMA
```{r}

burst_keep_cols <- c("participant_ID", "burst_ema_completed_num", "burst_ema_original_prompted_num", "burst_ema_expected_num")

selected_BURST_df <- burst_df[, burst_keep_cols]

```

Now create a function to return the completely aggregated df
```{r}

selected_BURST_df$burst_ema_completed_num <- as.numeric(selected_BURST_df$burst_ema_completed_num)
selected_BURST_df$burst_ema_original_prompted_num <- as.numeric(selected_BURST_df$burst_ema_original_prompted_num)
selected_BURST_df$burst_ema_expected_num <- as.numeric(selected_BURST_df$burst_ema_expected_num)

aggregate_burst_df <- function(df){
  
  df1 <- df[, c("participant_ID", "burst_ema_completed_num", "burst_ema_original_prompted_num", "burst_ema_expected_num")]
  num_burst_days_df <- df %>% count(participant_ID)
  df2 <- aggregate(.~participant_ID, df1, sum)
  df2$num_burst_days <- num_burst_days_df$n
  return(df2)
  
}

```

Use the function to get the aggregate df

```{r}

burst_pid_df <- aggregate_burst_df(selected_BURST_df)

```

Add compliance and completion rate columns
```{r}

burst_pid_df$burst_completion_rate <- burst_pid_df$burst_ema_completed_num/burst_pid_df$burst_ema_original_prompted_num
burst_pid_df$burst_compliance_rate <- burst_pid_df$burst_ema_completed_num/burst_pid_df$burst_ema_expected_num

```

## Combine burst and time pid df
```{r}

pid_burst_time_df <- join(time_pid_df, burst_pid_df)


```

## Get box plot distribution of compliance and validation percentages
```{r}

get_perc_box_plot <- function(df){
  keep_cols <- c("participant_ID", "uema_completion_rate", "uema_compliance_rate", "burst_completion_rate", "burst_compliance_rate", "uema_validation_perc")
  subset_df <- df[, keep_cols]
  names(subset_df) <- c("participant_ID", "uema_completion", "uema_compliance", "ema_completion", "ema_compliance", "uema_validation")
  df_melt <- melt(subset_df, id.var="participant_ID")
  
  uema <- expression(paste(mu, "EMA"))
  uema_completion <- paste(uema, " completion")
  uema_compliance <- paste(uema, " compliance")
  ema_compliance <- "EMA compliance"
  ema_completion <- "EMA completion"
  uema_validation <- paste(uema, " validation")
  
  box_comp_plot<- ggplot(data = df_melt, aes(x=variable, y=value)) + 
  geom_boxplot() + 
  stat_summary(fun.y = mean, geom = "errorbar", aes(ymax= ..y.., ymin = ..y..),
               width = 0.75, linetype="dashed") +
  ylim(0, 1) +
  # ggtitle("Compliance, completion, and validation rate") +
    xlab("") +
    ylab("Rate") +
    # theme(axis.title = element_text(size = 50), axis.text = element_text(size = 20))
    # theme(axis.title.y = element_text(size = 50), axis.text.y = element_text(size = 20)) +
    # theme(title = element_text(size = 30)) +
    theme_bw() +
    theme(axis.title = element_text(size = 15), axis.text.x = element_text(size = 15, colour = "black"), axis.text.y = element_text(size = 15, colour = "black"), title = element_text(size = 15), legend.text = element_text(size=15)) +
    scale_x_discrete(labels=c(expression(paste(mu, "EMA completion")), expression(paste(mu, "EMA compliance")), "EMA completion", "EMA compliance", expression(paste(mu, "EMA validation")))) +
    stat_summary(fun.y = mean, geom = "errorbar", aes(ymax= ..y.., ymin = ..y.., color = "Mean"),
               width = 0.75, linetype="solid") +
    stat_summary(fun.y = median, geom = "errorbar", aes(ymax= ..y.., ymin = ..y.., color = "Median"),
               width = 0.75, linetype="solid") +
     scale_colour_manual("", values = c(Median = "blue", Mean = "red")) +
  theme(
    legend.position = c(0.65, 0.12)
    # panel.grid.major.y = element_line(c(0, 25, 50, 75, 100),
    #   color = "#D9D9D9",
    #   size = 15)
  ) +
    guides(colour = guide_legend(nrow = 1)) +
    ggtitle("For completed participants")
  
  return(box_comp_plot)
}

```

Get the plot
```{r}

uema_burst_boxplot <- get_perc_box_plot(pid_burst_time_df)

ggsave(
  "uema_compliance_12m.png",
  plot = uema_burst_boxplot,
  device = "png",
  path = "D:/uema_ema_comparison_CHI/revised_thesis_plots",
  scale = 1,
  height = 5,
  width = 10,
  units = "in",
  limitsize = FALSE,
  dpi = 300
)

```

## Get a participant wise adjacent bar plot

Get a plot to check participant wise burst ema compliance completion and other data side by side.
Might be useful to see if there are commonalities


```{r}

get_adjacent_bar_plots <- function(df){
  keep_cols <- c("uema_completion_rate", "uema_compliance_rate", "burst_completion_rate", "burst_compliance_rate", "uema_validation_perc")
  df <- df[, keep_cols]
  df$p_no <- c(1:nrow(df))
  df$p_no <- as.character(df$p_no)
  
  df_melt <- melt(df, id.var = "p_no")
  adj_plot <- ggplot(data = df_melt, aes(x = p_no, y = value, fill = variable)) +
    geom_bar(stat = 'identity', position = 'dodge') +
    ggtitle('response and validation rates by participants') +
    xlab("") +
    ylab("Rate") +
    theme_bw()
  
  return(adj_plot)
  
}

```

or create a facet plot
```{r}

get_facet_rate_plot <- function(df){
  keep_cols <- c("uema_completion_rate", "uema_compliance_rate", "burst_completion_rate", "burst_compliance_rate", "uema_validation_perc")
  df <- df[, keep_cols]
  df$p_no <- c(1:nrow(df))
  df$p_no <- as.character(df$p_no)
  
  df_melt <- melt(df, id.var = "p_no")
  adj_plot <- ggplot(data = df_melt, aes(x = p_no, y = value)) +
    geom_bar(stat = 'identity') +
    ggtitle('response and validation rates by participants') +
    facet_wrap(variable~., ncol = 1)
}

```


Now, get the plot
```{r}

adj_plot <- get_facet_rate_plot(pid_burst_time_df)

```

Get a general correlation matrix for participant's response rates
```{r}

get_cor_matrix_plot <- function(df){
  keep_cols <- c("uema_completion_rate", "uema_compliance_rate", "burst_completion_rate", "burst_compliance_rate", "uema_validation_perc")
  df <- df[, keep_cols]
  cor_mat <- cor(df)
  
  col <- colorRampPalette(c("#BB4444", "#EE9988", "#FFFFFF", "#77AADD", "#4477AA"))
  cor_plot <- corrplot(cor_mat, method="color", col=col(200),  
         type="upper", order="hclust", 
         addCoef.col = "black", # Add coefficient of correlation
         tl.col="black", tl.srt=45, #Text label color and rotation
         # Combine with significance
         #p.mat = p.mat, sig.level = 0.01, insig = "blank", 
         # hide correlation coefficient on the principal diagonal
         diag=FALSE 
         )
  
  
  
  
  # cor_plot <- corrplot(cor_mat, method = "number", type = "upper", order = "hclust")
  return(cor_plot)
}

```

Get corrplot
```{r}

cor_plot <- get_cor_matrix_plot(pid_burst_time_df)


```

## Remove the outlier participant(s)
Compare the outlier vs not outlier comliance and completion rates
```{r}

pid_burst_time_sans_outlier_df <- subset(pid_burst_time_df, pid_burst_time_df$participant_ID != "uniformlyharmfulbush@timestudy_com")


```


## Get the long format day wise completed, prompted, and answered prompts
```{r}

burst_df$date_stamp <- as.POSIXct(burst_df$date, format = "%Y-%m-%d")

burst_subset_df <- burst_df[, c("participant_ID", "date", "study_mode", "date_stamp", "uema_completed_num", "uema_prompted_num", "burst_ema_completed_num", "burst_ema_original_prompted_num", "burst_ema_expected_num")]

time_subset_df <- time_df[, c("participant_ID", "date", "study_mode", "date_stamp", "uema_completed_num", "uema_prompted_num", "burst_ema_completed_num", "burst_ema_original_prompted_num", "uema_expected_num")]

```

row bind them
```{r}

colnames(burst_subset_df)[9] <- "expected_num"
colnames(time_subset_df)[9] <- "expected_num"

clean_time_burst_df <- rbind(burst_subset_df, time_subset_df)

```

Group by p_id and then sort by date_stamp
```{r}

clean_time_burst_df <- arrange(clean_time_burst_df, participant_ID, date_stamp)

```

Finally, create a sum column and convert to numerics
```{r}

cols.num <- c("uema_completed_num", "uema_prompted_num", "burst_ema_completed_num", "burst_ema_original_prompted_num", "expected_num")
clean_time_burst_df[cols.num] <- sapply(clean_time_burst_df[cols.num],as.numeric)


```

Convert NAs to zero
```{r}

clean_time_burst_df[is.na(clean_time_burst_df)] <- 0

```

Add into single column
```{r}

clean_time_burst_df$prompted <- clean_time_burst_df$uema_prompted_num + clean_time_burst_df$burst_ema_original_prompted_num
clean_time_burst_df$completed <- clean_time_burst_df$uema_completed_num + clean_time_burst_df$burst_ema_completed_num

```

Write the user list to a file
```{r}

final_user_list <- unique(clean_time_burst_df$participant_ID)

final_user_list <- gsub("@timestudy_com", "", final_user_list)

write.csv(file = "D:/uema_ema_comparison_CHI/perceived_burden/final_user_list_12m.csv", final_user_list, sep = ",", row.names = FALSE, quote = FALSE)

```

## Perform glm for compliance and completion rate comparisons between uEMA and EMA

Prepare data
```{r}
names(clean_time_burst_df) <- c("P_ID", "DATE", "TYPE", "DATE_STAMP", "UEMA_COMPLETED", "UEMA_PROMPTED", "EMA_COMPLETED", "EMA_PROMPTED", "TOTAL_EXPECTED", "TOTAL_PROMPTED", "TOTAL_COMPLETED")

```

Add a column of failures for expected and delivered prompts - correct for incorrect expected number of prompts
```{r}

for (i in 1:nrow(clean_time_burst_df)){
  if (clean_time_burst_df$TOTAL_EXPECTED[i] < clean_time_burst_df$TOTAL_PROMPTED[i]){
    clean_time_burst_df$TOTAL_EXPECTED[i] = clean_time_burst_df$TOTAL_PROMPTED[i]
  }
}



clean_time_burst_df$EXPD_MISSED <- clean_time_burst_df$TOTAL_EXPECTED - clean_time_burst_df$TOTAL_COMPLETED
clean_time_burst_df$PMPD_MISSED <- clean_time_burst_df$TOTAL_PROMPTED - clean_time_burst_df$TOTAL_COMPLETED


```

Convert TYPE to numeric
```{r}

clean_time_burst_df$TYPE_NUM[clean_time_burst_df$TYPE == "BURST"] <- 0
clean_time_burst_df$TYPE_NUM[clean_time_burst_df$TYPE == "TIME"] <- 1

```


Run the completion model
```{r}
completion_mod <- glmer(cbind(TOTAL_COMPLETED, PMPD_MISSED) ~ TYPE_NUM + (1 | P_ID), family = "binomial", data=clean_time_burst_df)

# print(completion_mod, corr = FALSE)

summary(completion_mod)

```

Get CIs and odds ratios
```{r}

completion_se <- sqrt(diag(vcov(completion_mod)))
# table of estimates with 95% CI
(completion_tab <- cbind(Est = fixef(completion_mod), LL = fixef(completion_mod) - 1.96 * completion_se, UL = fixef(completion_mod) + 1.96 *
    completion_se))

exp(completion_tab)

```




Add a test compliance column
```{r}

clean_time_burst_df$COMPLIANCE <- clean_time_burst_df$TOTAL_COMPLETED/clean_time_burst_df$TOTAL_EXPECTED

# clean_time_burst_df$COMPLIANCE[clean_time_burst_df$COMPLIANCE >= 1.0] <- 1.0

# clean_time_burst_df <- subset(clean_time_burst_df, clean_time_burst_df$COMPLIANCE >= 0)

# clean_time_burst_df$TOTAL_EXPECTED[clean_time_burst_df$TOTAL_EXPECTED < clean_time_burst_df$TOTAL_PROMPTED] <- clean_time_burst_df$TOTAL_PROMPTED

```


Run the compliance model
```{r}

compliance_mod <- glmer(cbind(TOTAL_COMPLETED, EXPD_MISSED) ~ TYPE_NUM + (1 | P_ID), family = "binomial", data=clean_time_burst_df)

# print(completion_mod, corr = FALSE)

summary(compliance_mod)


```

Get CIs and odds ratios
```{r}

compliance_se <- sqrt(diag(vcov(compliance_mod)))
# table of estimates with 95% CI
(compiance_tab <- cbind(Est = fixef(compliance_mod), LL = fixef(compliance_mod) - 1.96 * compliance_se, UL = fixef(completion_mod) + 1.96 *
    compliance_se))

exp(compiance_tab)


```

## Plot seasonality for uEMA

```{r}

plot_seasonality_uema <- function(df){
  
  to_keep <- c("participant_ID", "days_into_study", "uema_compliance_rate", "uema_completion_rate")
  df <- df[, to_keep]
  
  df <- df %>% group_by(participant_ID) %>% mutate(actual_days = row_number())
  
  max_day <- max(df$actual_days)
  split_val <- max_day/2
  
  keep_only <- c("actual_days", "uema_compliance_rate", "uema_completion_rate")
  
  df <- df[, keep_only]
  
  df <- reshape2::melt(df, id.var='actual_days')
  
  line_plot <- ggplot(data=df, aes(x=actual_days, y=value, color = variable)) +
    # geom_line(size = 1) +
    # geom_point() +
    theme_bw() +
    scale_y_continuous(limits = c(0, 1), breaks = seq(0, 1, by = 0.5)) +
    scale_x_continuous(limits = c(0, 260), breaks = seq(0, 260, by = 130)) +
    # scale_x_discrete(labels = c("Home", "School", "Work", "Friend", "Unlabeled", "Transit", "Other")) +
    # theme(axis.text.x = element_text(angle = 45, margin = margin(t = 5))) +
    # stat_summary(geom="ribbon", fun.data=mean_cl_normal, conf.int=0.95, fill="lightblue", alpha = 0.5) +
    stat_summary(fun.y = mean, geom = "line", aes(ymax= ..y.., ymin = ..y..),
               width = 0.1, size = 1) +
    # scale_colour_manual("", values = c(Compliance = "blue", Completion = "red")) +
    # scale_y_continuous(breaks = c(0, 0.5, 1.0), label = c("0", "0.5", "1.0")) +
    labs(x = "", y = "Rate", color = "Rate type") +
    scale_color_manual(labels = c("Compliance rate", "Completion rate"), values = c("red", "blue")) +
    theme(axis.title = element_text(size = 15), axis.text.x = element_text(size = 15, colour = "black"), axis.text.y = element_text(size = 15, colour = "black"), title = element_text(size = 15), axis.title.x=element_blank(), legend.text = element_text(size = 15)) +
    ggtitle("µEMA response rates") +
    theme(
    legend.position = c(0.50, 0.25)
    # panel.grid.major.y = element_line(c(0, 25, 50, 75, 100),
    #   color = "#D9D9D9",
    #   size = 15)
  ) +
    guides(colour = guide_legend(nrow = 2))
  
  return(line_plot)
  
}

```

## Plot seasonality for EMA

```{r}

plot_seasonality_ema <- function(df){
  
  to_keep <- c("participant_ID", "days_into_study", "burst_ema_compliance_rate", "burst_ema_completion_rate")
  df <- df[, to_keep]
  
  df <- df %>% group_by(participant_ID) %>% mutate(actual_days = row_number())
  
  max_day <- max(df$actual_days)
  split_val <- max_day/2
  
  keep_only <- c("actual_days", "burst_ema_compliance_rate", "burst_ema_completion_rate")
  
  df <- df[, keep_only]
  
  df <- reshape2::melt(df, id.var='actual_days')
  
  line_plot <- ggplot(data=df, aes(x=actual_days, y=value, color = variable)) +
    # geom_line(size = 1) +
    # geom_point() +
    theme_bw() +
    scale_y_continuous(limits = c(0, 1), breaks = seq(0, 1, by = 0.5)) +
    scale_x_continuous(limits = c(0, 106), breaks = seq(0, 106, by = 53)) +
    # scale_x_discrete(labels = c("Home", "School", "Work", "Friend", "Unlabeled", "Transit", "Other")) +
    # theme(axis.text.x = element_text(angle = 45, margin = margin(t = 5))) +
    # stat_summary(geom="ribbon", fun.data=mean_cl_normal, conf.int=0.95, fill="lightblue", alpha = 0.5) +
    stat_summary(fun.y = mean, geom = "line", aes(ymax= ..y.., ymin = ..y..),
               width = 0.1, size = 1) +
    # scale_colour_manual("", values = c(Compliance = "blue", Completion = "red")) +
    # scale_y_continuous(breaks = c(0, 0.5, 1.0), label = c("0", "0.5", "1.0")) +
    labs(x = "", y = "Rate", color = "Rate type") +
    scale_color_manual(labels = c("Compliance rate", "Completion rate"), values = c("red", "blue")) +
    theme(axis.title = element_text(size = 15), axis.text.x = element_text(size = 15, colour = "black"), axis.text.y = element_text(size = 15, colour = "black"), title = element_text(size = 15), axis.title.x=element_blank(), legend.text = element_text(size = 15)) +
    ggtitle("EMA response rates") +
    theme(
    legend.position = c(0.50, 0.25)
    # panel.grid.major.y = element_line(c(0, 25, 50, 75, 100),
    #   color = "#D9D9D9",
    #   size = 15)
  ) +
    guides(colour = guide_legend(nrow = 2))
  
  return(line_plot)
  
}

```

## Plot participant distribution by days
```{r}

plot_num_part_days <- function(df, type){
  
  if (type == "uema"){
    max_limit = 260
    day_type = "µEMA days"
    
  } else if (type == "ema"){
    max_limit = 106
    day_type = "EMA days"
  }
  
  split_val = max_limit/2
  
  
  keep_names <- c("participant_ID", "days_into_study")
  df <- df[, keep_names]
  
  df <- df %>% group_by(participant_ID) %>% mutate(actual_days = row_number())
  
  
  df <- df[, c("participant_ID", "actual_days")]
  
  
  # agg_df <- distinct(df)
  
  agg_df <- aggregate(df$actual_days, by = list(df$actual_days), FUN = length)
  names(agg_df) <- c("Days", "Num_Ps")
  
  agg_df$Days <- as.numeric(agg_df$Days)
  
  # agg_df <- summarise(group_by(df,Participant_ID, EXPOSURE_DAY_NO),length(Participant_ID))
  # names(agg_df) <- c("Participant_ID", "max_expo_day", "COUNT")
  # 
  # agg_df <- agg_df %>%
  # group_by(Participant_ID, max_expo_day) %>%
  # mutate(COMPLETION_RATE = COUNT / sum(COUNT))
  # 
  # agg_df <- subset(agg_df, agg_df$ANSWER_STATUS == "Answered")
  # 
  # agg_df$max_expo_day <- as.numeric(agg_df$max_expo_day)
  # 
  line_plot <- ggplot(data=agg_df, aes(x=Days, y=Num_Ps)) +
    geom_line(size = 1) +
    # geom_point() +
    theme_bw() +
    scale_y_continuous(limits = c(0, 50), breaks = seq(0, 50, by = 25)) +
    scale_x_continuous(limits = c(0, max_limit), breaks = seq(0, max_limit, by = split_val)) +
    # scale_x_discrete(labels = c("Home", "School", "Work", "Friend", "Unlabeled", "Transit", "Other")) +
    # theme(axis.text.x = element_text(angle = 45, margin = margin(t = 5))) +
    # stat_summary(geom="ribbon", fun.data=mean_cl_normal, conf.int=0.95, fill="lightblue", alpha = 0.5) +
    # stat_summary(fun.y = mean, geom = "line", aes(ymax= ..y.., ymin = ..y..),
    #            width = 0.1, size = 1) +
    # scale_y_continuous(breaks = c(0, 0.5, 1.0), label = c("0", "0.5", "1.0")) +
    labs(x = day_type, y = "No. participants") +
    theme(axis.title = element_text(size = 15), axis.text.x = element_text(size = 15, colour = "black"), axis.text.y = element_text(size = 15, colour = "black"), title = element_text(size = 15))
   
  
   # ylim(0, 1) +
    # xlim(0, 300)
  
  # box_plot <- ggplot(agg_df, aes(x=DAYS_IN_THE_STUDY, y=COMPLETION_RATE)) + 
  # geom_boxplot() +
  #   ggtitle("Completion | Days in the study")
  # 
  # summary_object <- describeBy(agg_df$COMPLETION_RATE, group = agg_df$DAYS_IN_THE_STUDY)
  # 
  # print(summary_object)
  
  # return_list <- c(summary_object, box_plot)
  
  return(line_plot)
}

```

## Place plots vertically
```{r}

library(ggpubr)

uema_seasonality <- plot_seasonality_uema(time_df)
ema_seasonality <- plot_seasonality_ema(burst_df)
uema_num <- plot_num_part_days(time_df, "uema")
ema_num <- plot_num_part_days(burst_df, "ema")

uema_arranged <- ggarrange(uema_seasonality, uema_num, ncol = 1, nrow = 2)
ema_arranged <- ggarrange(ema_seasonality, ema_num, ncol = 1, nrow = 2)

```

Save the plots
```{r}

ggsave(
    "uema_season_12m.png",
    plot = uema_arranged,
    device = "png",
    path = "D:/uema_ema_comparison_CHI/revised_thesis_plots",
    scale = 1,
    height = 6,
    width = 5,
    units = "in",
    limitsize = FALSE,
    dpi = 300
)


ggsave(
    "ema_season_12m.png",
    plot = ema_arranged,
    device = "png",
    path = "D:/uema_ema_comparison_CHI/revised_thesis_plots",
    scale = 1,
    height = 6,
    width = 5,
    units = "in",
    limitsize = FALSE,
    dpi = 300
)


```

Return actual days column

```{r}


return_actual_days <- function(df){
   keep_names <- c("participant_ID", "burst_ema_compliance_rate", "burst_ema_completion_rate", "days_into_study")
  df <- df[, keep_names]
  
  df <- df %>% group_by(participant_ID) %>% mutate(actual_days = row_number())
  
  
  df <- df[, c("participant_ID", "burst_ema_compliance_rate", "burst_ema_completion_rate", "actual_days")]
  return(df)
}

```

Return the last burst for participants
```{r}

return_last_burst <- function(df, num_days){
  
  df <- df %>% 
   group_by(participant_ID) %>% 
   slice(tail(row_number(), num_days))
  
  return(df)
  
}

```

Day by day changes in min of DND and battery off - watch
```{r}

plot_data_loss_sources_watch <- function(df){
  
  to_keep <- c("participant_ID", "days_into_study", "watch_off_dur_shut", "watch_dnd_mode_min")
  df <- df[, to_keep]
  
  # df$watch_off_dur_shut <- as.numeric(df$watch_off_dur_shut)
  # df$watch_dnd_mode_min <- as.numeric(df$watch_dnd_mode_min)
  
  df <- df %>% group_by(participant_ID) %>% mutate(actual_days = row_number())
  
  # max_day <- max(df$actual_days)
  # split_val <- max_day/2
  
  
  keep_only <- c("actual_days", "watch_off_dur_shut", "watch_dnd_mode_min")
  
  df <- df[, keep_only]
  
  df <- reshape2::melt(df, id.var='actual_days')
  
  df$value <- as.numeric(df$value)
  
  max_min <- max(df$value, na.rm = TRUE)
  split_val <- max_min/2

  # print(max_min)
  # print(split_val)
  
  line_plot <- ggplot(data=df, aes(x=actual_days, y=value, color = variable)) +
    # geom_line(size = 1) +
    # geom_point() +
    theme_bw() +
    # ylim(0,300) +
    # scale_y_continuous(limits = c(0, 300, breaks = seq(0, 300, by = 150))) +
    scale_y_continuous(limits = c(0, 1500, breaks = seq(0, 1500, by = 300))) +
    scale_x_continuous(limits = c(0, 260), breaks = seq(0, 260, by = 130)) +
    # scale_x_discrete(labels = c("Home", "School", "Work", "Friend", "Unlabeled", "Transit", "Other")) +
    # theme(axis.text.x = element_text(angle = 45, margin = margin(t = 5))) +
    # stat_summary(geom="ribbon", fun.data=mean_cl_normal, conf.int=0.95, fill="lightblue", alpha = 0.5) +
    stat_summary(fun.y = mean, geom = "line", aes(ymax= ..y.., ymin = ..y..),
               width = 0.1, size = 1) +
    # scale_colour_manual("", values = c(Compliance = "blue", Completion = "red")) +
    # scale_y_continuous(breaks = c(0, 0.5, 1.0), label = c("0", "0.5", "1.0")) +
    labs(x = "", y = "Minutes per day", color = "Watch is") +
    scale_color_manual(labels = c("off", "in DnD"), values = c("red", "blue")) +
    theme(axis.title = element_text(size = 15), axis.text.x = element_text(size = 15, colour = "black"), axis.text.y = element_text(size = 15, colour = "black"), title = element_text(size = 15), axis.title.x=element_blank(), legend.text = element_text(size = 15)) +
    ggtitle("µEMA data loss sources") +
    theme(
    legend.position = c(0.25, 0.85)
    # panel.grid.major.y = element_line(c(0, 25, 50, 75, 100),
    #   color = "#D9D9D9",
    #   size = 15)
  ) +
    guides(colour = guide_legend(nrow = 1))
  
  return(line_plot)
  
}

```

Do the same for EMA/phone
```{r}

plot_data_loss_sources_phone <- function(df){
  
  to_keep <- c("participant_ID", "days_into_study", "phone_off_min", "phone_dnd_mode_min")
  df <- df[, to_keep]
  
  # df$watch_off_dur_shut <- as.numeric(df$watch_off_dur_shut)
  # df$watch_dnd_mode_min <- as.numeric(df$watch_dnd_mode_min)
  
  df <- df %>% group_by(participant_ID) %>% mutate(actual_days = row_number())
  
  # max_day <- max(df$actual_days)
  # split_val <- max_day/2
  
  
  keep_only <- c("actual_days", "phone_off_min", "phone_dnd_mode_min")
  
  df <- df[, keep_only]
  
  df <- reshape2::melt(df, id.var='actual_days')
  
  df$value <- as.numeric(df$value)
  
  max_min <- max(df$value, na.rm = TRUE)
  split_val <- max_min/2

  # print(max_min)
  # print(split_val)
  
  line_plot <- ggplot(data=df, aes(x=actual_days, y=value, color = variable)) +
    # geom_line(size = 1) +
    # geom_point() +
    theme_bw() +
    # ylim(0,300) +
    # scale_y_continuous(limits = c(0, 300, breaks = seq(0, 300, by = 150))) +
    scale_x_continuous(limits = c(0, 106), breaks = seq(0, 106, by = 53)) +
    # scale_x_discrete(labels = c("Home", "School", "Work", "Friend", "Unlabeled", "Transit", "Other")) +
    # theme(axis.text.x = element_text(angle = 45, margin = margin(t = 5))) +
    # stat_summary(geom="ribbon", fun.data=mean_cl_normal, conf.int=0.95, fill="lightblue", alpha = 0.5) +
    stat_summary(fun.y = mean, geom = "line", aes(ymax= ..y.., ymin = ..y..),
               width = 0.1, size = 1) +
    # scale_colour_manual("", values = c(Compliance = "blue", Completion = "red")) +
    # scale_y_continuous(breaks = c(0, 0.5, 1.0), label = c("0", "0.5", "1.0")) +
    labs(x = "", y = "Minutes per day", color = "Phone is") +
    scale_color_manual(labels = c("off", "in DnD"), values = c("red", "blue")) +
    theme(axis.title = element_text(size = 15), axis.text.x = element_text(size = 15, colour = "black"), axis.text.y = element_text(size = 15, colour = "black"), title = element_text(size = 15), axis.title.x=element_blank(), legend.text = element_text(size = 15)) +
    ggtitle("EMA data loss sources") +
    theme(
    legend.position = c(0.25, 0.85)
    # panel.grid.major.y = element_line(c(0, 25, 50, 75, 100),
    #   color = "#D9D9D9",
    #   size = 15)
  ) +
    guides(colour = guide_legend(nrow = 1))
  
  return(line_plot)
  
}


```

Save plots to objects
```{r}
uema_data_loss <- plot_data_loss_sources_watch(time_df)
ema_data_loss <- plot_data_loss_sources_phone(burst_df)

uema_data_loss_arranged <- ggarrange(uema_data_loss, uema_num, ncol = 1, nrow = 2)
ema_data_loss_arranged <- ggarrange(ema_data_loss, ema_num, ncol = 1, nrow = 2)


```

Save the files
```{r}

ggsave(
    "uema_loss_12m.png",
    plot = uema_data_loss_arranged,
    device = "png",
    path = "D:/uema_ema_comparison_CHI/revised_thesis_plots",
    scale = 1,
    height = 6,
    width = 5,
    units = "in",
    limitsize = FALSE,
    dpi = 300
)


ggsave(
    "ema_loss_12m.png",
    plot = ema_data_loss_arranged,
    device = "png",
    path = "D:/uema_ema_comparison_CHI/revised_thesis_plots",
    scale = 1,
    height = 6,
    width = 5,
    units = "in",
    limitsize = FALSE,
    dpi = 300
)


```

Get the last 6 months
```{r}

time_last_6m_df <- return_last_burst(time_df, 130)

```

Plot boxplot by participant
```{r}

plot_watch_battery_box_plot <- function(df){
  keep <- c("participant_ID", "watch_off_dur_shut")
  df <- df[, keep]
  df$watch_off_dur_shut <- as.numeric(df$watch_off_dur_shut)
  
  df$participant_ID <- gsub("@timestudy_com", "" ,df$participant_ID)
  
  box_comp_plot<- ggplot(data = df, aes(x=participant_ID, y=watch_off_dur_shut)) + 
  geom_boxplot() + 
  stat_summary(fun.y = mean, geom = "errorbar", aes(ymax= ..y.., ymin = ..y..),
               width = 0.75, linetype="dashed") +
  ylim(0, 1440) +
  # ggtitle("Compliance, completion, and validation rate") +
    xlab("") +
    ylab("Minutes per day") +
    # theme(axis.title = element_text(size = 50), axis.text = element_text(size = 20))
    # theme(axis.title.y = element_text(size = 50), axis.text.y = element_text(size = 20)) +
    # theme(title = element_text(size = 30)) +
    theme_bw() +
    theme(axis.text.x = element_text(angle = 90)) +
    theme(axis.title = element_text(size = 15), axis.text.x = element_text(size = 15, colour = "black"), axis.text.y = element_text(size = 15, colour = "black"), title = element_text(size = 15), legend.text = element_text(size=15)) +
    stat_summary(fun.y = mean, geom = "errorbar", aes(ymax= ..y.., ymin = ..y.., color = "Mean"),
               width = 0.75, linetype="solid") +
    stat_summary(fun.y = median, geom = "errorbar", aes(ymax= ..y.., ymin = ..y.., color = "Median"),
               width = 0.75, linetype="solid") +
     scale_colour_manual("", values = c(Median = "blue", Mean = "red")) +
  # theme(
  #   legend.position = c(0.65, 0.12)
  #   # panel.grid.major.y = element_line(c(0, 25, 50, 75, 100),
  #   #   color = "#D9D9D9",
  #   #   size = 15)
  # ) +
  #   guides(colour = guide_legend(nrow = 1)) +
    ggtitle("Watch off")
  
  return(box_comp_plot)
  
}

```

Plot for dnd duration
```{r}

plot_watch_dnd_box_plot <- function(df){
  keep <- c("participant_ID", "watch_dnd_mode_min")
  df <- df[, keep]
  df$watch_dnd_mode_min <- as.numeric(df$watch_dnd_mode_min)
  
  df$participant_ID <- gsub("@timestudy_com", "" ,df$participant_ID)
  
  box_comp_plot<- ggplot(data = df, aes(x=participant_ID, y=watch_dnd_mode_min)) + 
  geom_boxplot() + 
  stat_summary(fun.y = mean, geom = "errorbar", aes(ymax= ..y.., ymin = ..y..),
               width = 0.75, linetype="dashed") +
  ylim(0, 1440) +
  # ggtitle("Compliance, completion, and validation rate") +
    xlab("") +
    ylab("Minutes per day") +
    # theme(axis.title = element_text(size = 50), axis.text = element_text(size = 20))
    # theme(axis.title.y = element_text(size = 50), axis.text.y = element_text(size = 20)) +
    # theme(title = element_text(size = 30)) +
    theme_bw() +
    theme(axis.text.x = element_text(angle = 90)) +
    theme(axis.title = element_text(size = 15), axis.text.x = element_text(size = 15, colour = "black"), axis.text.y = element_text(size = 15, colour = "black"), title = element_text(size = 15), legend.text = element_text(size=15)) +
    stat_summary(fun.y = mean, geom = "errorbar", aes(ymax= ..y.., ymin = ..y.., color = "Mean"),
               width = 0.75, linetype="solid") +
    stat_summary(fun.y = median, geom = "errorbar", aes(ymax= ..y.., ymin = ..y.., color = "Median"),
               width = 0.75, linetype="solid") +
     scale_colour_manual("", values = c(Median = "blue", Mean = "red")) +
  # theme(
  #   legend.position = c(0.65, 0.12)
  #   # panel.grid.major.y = element_line(c(0, 25, 50, 75, 100),
  #   #   color = "#D9D9D9",
  #   #   size = 15)
  # ) +
  #   guides(colour = guide_legend(nrow = 1)) +
    ggtitle("Watch DnD")
  
  return(box_comp_plot)
  
}

```

Get the plotting objects
```{r}

uema_battery_loss <- plot_watch_battery_box_plot(time_last_6m_df)
uema_dnd_loss <- plot_watch_dnd_box_plot(time_last_6m_df)

```

Save the plots
```{r}

ggsave(
    "uema_battery_loss_12m.png",
    plot = uema_battery_loss,
    device = "png",
    path = "D:/uema_ema_comparison_CHI/revised_thesis_plots",
    scale = 1,
    height = 5,
    width = 10,
    units = "in",
    limitsize = FALSE,
    dpi = 300
)


ggsave(
    "ema_dnd_loss_12m.png",
    plot = uema_dnd_loss,
    device = "png",
    path = "D:/uema_ema_comparison_CHI/revised_thesis_plots",
    scale = 1,
    height = 5,
    width = 10,
    units = "in",
    limitsize = FALSE,
    dpi = 300
)


```

## Get test ID subsets
```{r}

get_id_subset <- function(df, pid){
  df <- subset(df, df$participant_ID == pid)
  return(df)
}

```

Apply and get plots
```{r}

id_select = "resupplyclappingyahoo@timestudy_com"

id_subset <- get_id_subset(time_df, id_select)

id_plot <- plot_data_loss_sources_watch(id_subset)

```

